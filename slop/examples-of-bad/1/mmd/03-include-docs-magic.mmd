%% Diagram 3: include_docs Magic
%% Like email notifications - preview only vs full message included
%% Author: As explained by Laurie Voss to a new engineer

flowchart TB
  %% ---- The Choice ----
  subgraph Choice["ğŸ¤” The include_docs Decision"]
    Q["Do you want the full document<br/>with every change?"]
  end

  %% ---- Without include_docs (Default) ----
  subgraph Without["ğŸ” include_docs=false (Default)"]
    W1["ğŸ“¨ Change Event<br/><code>{<br/>  seq: '1001',<br/>  id: 'express',<br/>  rev: '2-abc'<br/>}</code><br/>Size: ~200 bytes"]

    W2["â“ Need full doc?"]

    W3["ğŸŒ Separate Request<br/><code>GET /express</code>"]

    W4["ğŸ“„ Full Document<br/>Size: ~50KB - 2MB<br/>(for popular packages)"]

    W1 --> W2
    W2 -->|"YES"| W3
    W3 --> W4
  end

  %% ---- With include_docs ----
  subgraph With["ğŸ include_docs=true"]
    WI1["ğŸ“¦ Change Event + Document<br/><code>{<br/>  seq: '1001',<br/>  id: 'express',<br/>  rev: '2-abc',<br/>  doc: {<br/>    name: 'express',<br/>    versions: {...},<br/>    // 50KB+ of data<br/>  }<br/>}</code><br/>Size: 50KB - 2MB"]

    WI2["âœ… Already have everything!<br/>No extra request needed"]

    WI1 --> WI2
  end

  Choice --> Without
  Choice --> With

  %% ---- Performance Comparison ----
  subgraph Perf["âš¡ Performance for 1000 Changes"]
    direction LR

    P1["âŒ <b>include_docs=false</b><br/>1 request for changes: 200KB<br/>+ 1000 doc requests<br/>= <b>1001 HTTP calls</b><br/>â±ï¸ ~2 seconds total"]

    P2["âœ… <b>include_docs=true</b><br/>1 request for everything: 50MB<br/>= <b>1 HTTP call</b><br/>â±ï¸ ~1.3 seconds total<br/>BUT uses more memory!"]
  end

  Without --> P1
  With --> P2

  %% ---- Real npm Registry Example ----
  subgraph NPM["ğŸ“Š Real npm Registry Numbers"]
    N1["ğŸ¢ Popular package '@types/node':<br/>Document size: >10MB<br/>Contains 300+ versions"]

    N2["ğŸ’¾ Memory usage with include_docs=true:<br/>100 changes Ã— 10MB = 1GB RAM!"]

    N3["ğŸ¯ Best Practice:<br/>Use include_docs=false for monitoring<br/>Use include_docs=true for full replication"]
  end

  Perf --> NPM

  %% ---- When to Use Each ----
  subgraph Decision["ğŸ“‹ Decision Matrix"]
    D1["<b>Use include_docs=false when:</b><br/>âœ“ Only monitoring for changes<br/>âœ“ Memory constrained<br/>âœ“ Selective processing<br/>âœ“ High-frequency polling"]

    D2["<b>Use include_docs=true when:</b><br/>âœ“ Full replication needed<br/>âœ“ Batch processing all changes<br/>âœ“ Network latency is high<br/>âœ“ Processing everything anyway"]
  end

  NPM --> Decision

  %% ---- Styling ----
  classDef choice     fill:#f0f4ff,stroke:#2196f3,stroke-width:2px;
  classDef without    fill:#fff3cd,stroke:#ffc107,stroke-width:2px;
  classDef with       fill:#d4edda,stroke:#28a745,stroke-width:2px;
  classDef perf       fill:#ffebee,stroke:#f44336,stroke-width:2px;
  classDef perfGood   fill:#d4edda,stroke:#28a745,stroke-width:2px;
  classDef npm        fill:#e3f2fd,stroke:#2196f3,stroke-width:2px;
  classDef decision   fill:#f5f5f5,stroke:#757575,stroke-width:1px;

  class Q choice;
  class W1,W2,W3,W4 without;
  class WI1,WI2 with;
  class P1 perf;
  class P2 perfGood;
  class N1,N2,N3 npm;
  class D1,D2 decision;